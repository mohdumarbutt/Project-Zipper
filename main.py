import io
import zipfile
from typing import Iterator

from fastapi import FastAPI, HTTPException
from fastapi.responses import StreamingResponse
from pydantic import BaseModel

# --- 1. Pydantic Model for Request Body ---
class TreeInput(BaseModel):
    """Defines the structure of the JSON input."""
    tree_structure: str
    root_dir_name: str = "project" # Default name for the root directory

app = FastAPI(
    title="ProjectZipper",
    description="Generate a downloadable ZIP file from a text-based file tree structure."
)

# --- 2. Core Logic: Parsing and Zipping ---

def parse_and_zip_project(
    tree_lines: list[str], 
    root_name: str, 
    zip_buffer: io.BytesIO
):
    """
    Parses tree lines, creates a zip archive in the in-memory buffer, 
    and adds files with placeholder content.
    """
    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_archive:
        # A set to keep track of created directories to avoid duplicates
        # and ensure files are placed correctly.
        created_dirs = set() 
        
        # Determine base path for zipping
        base_path = f"{root_name}/"
        
        # Add the root folder itself
        zip_archive.writestr(base_path, "")

        for line in tree_lines:
            line = line.strip()
            if not line:
                continue

            # Heuristic: Check for common tree characters
            # Removes "├── ", "└── ", "│   ", etc.
            clean_name = line.split(' ')[-1] 
            
            # The full path inside the zip file
            file_path = base_path + clean_name.replace("/", "") # Remove slashes from clean_name if present

            if clean_name.endswith('/'):
                # This is a directory (e.g., "src/")
                dir_path = file_path + "/"
                if dir_path not in created_dirs:
                    zip_archive.writestr(dir_path, "") # Write empty string for a directory entry
                    created_dirs.add(dir_path)
            elif clean_name:
                # This is a file (e.g., "main.js")
                
                # --- File Content Generation (Placeholder) ---
                if file_path.endswith('.js'):
                    content = f'// File: {file_path}\nconsole.log("Project Zipper generated this file.");'
                elif file_path.endswith(('.py', '.txt')):
                    content = f'# File: {file_path}\n# This content is a placeholder.'
                elif file_path.endswith(('.json')):
                    content = '{\n  "project": "generated by ProjectZipper"\n}'
                else:
                    content = f'File: {file_path}'
                    
                zip_archive.writestr(file_path, content.encode('utf-8'))
                
    zip_buffer.seek(0) # Rewind the buffer to the beginning

    # Generator function to stream the buffer content chunk by chunk
    def zip_streamer() -> Iterator[bytes]:
        """Reads the in-memory buffer in chunks."""
        chunk_size = 8192  # 8KB
        while True:
            chunk = zip_buffer.read(chunk_size)
            if not chunk:
                break
            yield chunk

    return zip_streamer()


# --- 3. FastAPI Endpoint ---

@app.post("/generate-zip", tags=["Generator"])
async def generate_zip_file(input_data: TreeInput):
    """
    Accepts a tree-like text structure, generates an in-memory ZIP file, 
    and returns it as a downloadable response.
    """
    
    # Pre-process the input
    lines = input_data.tree_structure.strip().split('\n')
    
    if not lines or not input_data.tree_structure.strip():
        raise HTTPException(status_code=400, detail="Input tree structure cannot be empty.")

    # Create an in-memory binary stream
    zip_buffer = io.BytesIO()
    
    # Perform the zipping
    try:
        stream = parse_and_zip_project(lines, input_data.root_dir_name, zip_buffer)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error during zip creation: {str(e)}")


    # Return the response as a stream
    response = StreamingResponse(
        stream,
        media_type="application/zip",
        headers={
            "Content-Disposition": f"attachment; filename={input_data.root_dir_name}.zip",
            "Content-Length": str(zip_buffer.getbuffer().nbytes)
        }
    )
    return response

# --- 4. Server Run Command (for local development) ---
if __name__ == "__main__":
    import uvicorn
    # Use 0.0.0.0 for Pydroid/Android to ensure it's accessible externally (e.g., from a browser)
    uvicorn.run(app, host="0.0.0.0", port=8000)
